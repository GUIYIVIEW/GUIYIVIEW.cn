<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GUIYIVIEW</title>
  
  <subtitle>生活随笔</subtitle>
  <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/"/>
  <updated>2022-11-04T07:38:40.441Z</updated>
  <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/</id>
  
  <author>
    <name>GUIYIVIEW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS LaunchScreen.storyboard启动图更新</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110408/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110408/</id>
    <published>2022-11-04T07:37:50.000Z</published>
    <updated>2022-11-04T07:38:40.441Z</updated>
    
    <content type="html"><![CDATA[<p>根据苹果要求2020年4月之后上线的APP都必须使用LaunchScreen适配启动图，在研究的过程中发现还是有一些坑的，记录一下。</p><p>环境: Xcode 11.3 + iPhone 11 + iOS 13.3</p><p>使用LaunchScreen设置启动图运行，之后更新图片内容，发现运行仍然是旧的图片。也试过网上的改名字、删除sb再新建、卸载重装、卸载+重启后重装，只有最后一项是每次都是正确的，前几项大多数情况下还是错误的。</p><p>使用模拟器测试发现，只有在全面屏时会更新失效。</p><p><strong>以下路径只在iOS 13系统下测试，其他设备的路径未测试。建议执行下面操作时每个版本只执行一次，否则不知道会不会出现黑白屏之类的情况。测试的时候没有执行下面代码，仅仅是频繁更换启动图就会出现黑白屏。</strong></p><h5 id="1-直接删除截图存放的路径目录"><a href="#1-直接删除截图存放的路径目录" class="headerlink" title="1.直接删除截图存放的路径目录"></a>1.直接删除截图存放的路径目录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/SplashBoard/Snapshots&quot;];</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtPath:path error:nil];</span><br></pre></td></tr></table></figure><p>可能有些莫名的情况下会会出现黑白屏，这时候使用<code>1</code>方法并不能完美解决，使用下面的<code>2</code>方法测试，即时是出现了黑屏，替换之后也可以显示正常。</p><h5 id="2-替换截图目录下文件"><a href="#2-替换截图目录下文件" class="headerlink" title="2.替换截图目录下文件"></a>2.替换截图目录下文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 获取截图存储路径</span><br><span class="line">NSString *bundleID = [[NSBundle mainBundle].infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];</span><br><span class="line">NSString *shotsDirName = [bundleID stringByAppendingString:@&quot; - &#123;DEFAULT GROUP&#125;&quot;];</span><br><span class="line">NSString *shotsPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/SplashBoard/Snapshots&quot;];</span><br><span class="line">shotsPath = [shotsPath stringByAppendingPathComponent:shotsDirName];</span><br><span class="line">NSError *readError = nil;</span><br><span class="line">NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:shotsPath error:&amp;readError];</span><br><span class="line">// 遍历该目录下截图文件</span><br><span class="line">for (NSString *fileName in files) &#123;</span><br><span class="line">    NSString *path = [shotsPath stringByAppendingPathComponent:fileName];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:path options:NSDataReadingMappedIfSafe error:&amp;error];</span><br><span class="line">    if (!error &amp;&amp; [data length]) &#123;</span><br><span class="line">        UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">        if (image) &#123;</span><br><span class="line">            UIImage *launchImage = [UIImage imageNamed:@&quot;launch&quot;];</span><br><span class="line">            // 设置图片尺寸为旧图尺寸</span><br><span class="line">            launchImage = [launchImage imageByResizeToSize:image.size contentMode:UIViewContentModeScaleAspectFit];</span><br><span class="line">            // 写入目录，替换旧图</span><br><span class="line">            NSData *launchData = UIImagePNGRepresentation(launchImage);</span><br><span class="line">            [launchData writeToFile:path atomically:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上两种方法都只能保证更新后二次启动是显示正确的，首次启动没找到办法。</strong></p><p>然而大多数人都想要酷炫的启动，创建出了很多启动动画，那么这时候对于苹果要求的一张图适配所有屏幕就可能会产生很多问题，比如图片在原有的坐标上可能发生偏移，而你也不知道到底偏移了多少。</p><p>看到有人提出这样的方案，原理还是跟之前的LaunchImage一样，但是不知道这个能不能在苹果最新的这个规则下上架。<a href="[https://juejin.im/post/5e1463d4f265da5d716e572d](https://juejin.im/post/5e1463d4f265da5d716e572d">此处是链接哦</a><br>)</p><p>以上仅限于个人只有一个手机，若有其他情况，大家也可以补充。</p><h2 id="更新：经过与苹果官方开发人员讨论，明确表示这种情况只在开发模式下频繁出现，在AppStore上不会出现。"><a href="#更新：经过与苹果官方开发人员讨论，明确表示这种情况只在开发模式下频繁出现，在AppStore上不会出现。" class="headerlink" title="更新：经过与苹果官方开发人员讨论，明确表示这种情况只在开发模式下频繁出现，在AppStore上不会出现。"></a>更新：经过与苹果官方开发人员讨论，明确表示这种情况只在开发模式下频繁出现，在AppStore上不会出现。</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据苹果要求2020年4月之后上线的APP都必须使用LaunchScreen适配启动图，在研究的过程中发现还是有一些坑的，记录一下。&lt;/p&gt;
&lt;p&gt;环境: Xcode 11.3 + iPhone 11 + iOS 13.3&lt;/p&gt;
&lt;p&gt;使用LaunchScreen设置启动</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
    <category term="启动图" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/%E5%90%AF%E5%8A%A8%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Swift Target-Action、Curring 设计模式</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110407/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110407/</id>
    <published>2022-11-04T07:36:50.000Z</published>
    <updated>2022-11-04T07:37:31.649Z</updated>
    
    <content type="html"><![CDATA[<p>自定义实现类似<code>UIButton</code>的<code>addTarget</code>事件响应链</p><h5 id="沿用OC调用方式"><a href="#沿用OC调用方式" class="headerlink" title="沿用OC调用方式"></a>沿用OC调用方式</h5><p>动态调用</p><p>声明<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weak var target: AnyObject?;</span><br><span class="line">var action: Selector?;</span><br><span class="line">func addTarget(_ target: AnyObject, selector: Selector) &#123;</span><br><span class="line">    self.target = target;</span><br><span class="line">    self.action = selector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if let target = target, let selector = action &#123;</span><br><span class="line">    if let method = class_getInstanceMethod(type(of: target), selector) &#123;</span><br><span class="line">        let imp = method_getImplementation(method);</span><br><span class="line">        typealias Function = @convention(c) (AnyObject, Selector, Any?) -&gt; ();</span><br><span class="line">        let function = unsafeBitCast(imp, to: Function.self);</span><br><span class="line">        function(target, selector, self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Swift-Curring柯里化方式"><a href="#Swift-Curring柯里化方式" class="headerlink" title="Swift Curring柯里化方式"></a>Swift Curring<code>柯里化</code>方式</h5><p>声明<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protocol TargetAction &#123;</span><br><span class="line">    func performAction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TargetActionWrapper&lt;T: AnyObject&gt;: TargetAction &#123;</span><br><span class="line">    weak var target: T?;</span><br><span class="line">    let action: (T) -&gt; () -&gt; ();</span><br><span class="line">    </span><br><span class="line">    func performAction() &#123;</span><br><span class="line">        if let t = target &#123;</span><br><span class="line">            action(t)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Model: NSObject &#123;</span><br><span class="line">    var wrapper: TargetAction?</span><br><span class="line">    func addTarget&lt;T: AnyObject&gt;(target: T, action: @escaping (T) -&gt; () -&gt; ()) &#123;</span><br><span class="line">         wrapper = TargetActionWrapper(target: target, action: action);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func invoke() &#123;</span><br><span class="line">        wrapper?.performAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let model = Model();</span><br><span class="line">model.addTarget(target: self, action: Test.invokeAction);</span><br><span class="line"></span><br><span class="line">func invokeAction() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>上面方法无法传递参数，需要进一步扩展。扩展可以根据自己需要，此处只简单举例。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protocol TargetAction &#123;</span><br><span class="line">    func performAction(_ userInfo: Any?);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct TargetActionWrapper&lt;T: AnyObject&gt;: TargetAction &#123;</span><br><span class="line">    weak var target: T?;</span><br><span class="line">    let action: (T) -&gt; (Any?) -&gt; ();</span><br><span class="line">    </span><br><span class="line">    func performAction(_ userInfo: Any?) &#123;</span><br><span class="line">        if let t = target &#123;</span><br><span class="line">            action(t)(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Model: NSObject &#123;</span><br><span class="line">    var wrapper: TargetAction?</span><br><span class="line">    var userInfo: Any?;</span><br><span class="line">    func addTarget&lt;T: AnyObject&gt;(target: T, action: @escaping (T) -&gt; (Any?) -&gt; (), userInfo: Any? = nil) &#123;</span><br><span class="line">        self.userInfo = userInfo;</span><br><span class="line">         wrapper = TargetActionWrapper(target: target, action: action);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func invoke() &#123;</span><br><span class="line">        wrapper?.performAction(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">let model = Model();</span><br><span class="line">model.addTarget(target: self, action: Test.invokeAction, userInfo: [&quot;a&quot;: &quot;b&quot;]);</span><br><span class="line"></span><br><span class="line">func invokeAction(_ sender: Any) &#123;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自定义实现类似&lt;code&gt;UIButton&lt;/code&gt;的&lt;code&gt;addTarget&lt;/code&gt;事件响应链&lt;/p&gt;
&lt;h5 id=&quot;沿用OC调用方式&quot;&gt;&lt;a href=&quot;#沿用OC调用方式&quot; class=&quot;headerlink&quot; title=&quot;沿用OC调用方式&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
    <category term="Swift" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/Swift/"/>
    
    <category term="设计模式" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃错误分析记录</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110406/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110406/</id>
    <published>2022-11-04T07:35:58.000Z</published>
    <updated>2022-11-04T07:36:32.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录各种疑难杂症"><a href="#记录各种疑难杂症" class="headerlink" title="记录各种疑难杂症"></a>记录各种疑难杂症</h3><h3 id="1-Terminating-app-due-to-uncaught-exception-‘UIApplicationInvalidInterfaceOrientation’-reason-‘Supported-orientations-has-no-common-orientation-with-the-application-and-UIAlertController-shouldAutorotate-is-returning-YES’"><a href="#1-Terminating-app-due-to-uncaught-exception-‘UIApplicationInvalidInterfaceOrientation’-reason-‘Supported-orientations-has-no-common-orientation-with-the-application-and-UIAlertController-shouldAutorotate-is-returning-YES’" class="headerlink" title="1. Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [UIAlertController shouldAutorotate] is returning YES’"></a>1. Terminating app due to uncaught exception ‘UIApplicationInvalidInterfaceOrientation’, reason: ‘Supported orientations has no common orientation with the application, and [UIAlertController shouldAutorotate] is returning YES’</h3><p>由于APP只支持竖屏，而在其中某个页面中单独设置支持横屏，在此横屏页面下，如果触发了某个业务弹出了<code>UIAlertController</code>，则会导致崩溃。网上有说写一个<code>UIAlertController</code>分类，在其中重写<code>shouldAutorotate</code>方法处理，然而写了之后并不会执行。<br>当然不仅仅是<code>UIAlertController</code>这一种情况，<code>UIImagePickerViewController</code>这种系统的东西都有可能触发。<br>解决方案：在<code>AppDelegate</code>中实现以下方法根据实际业务判断处理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class="line">    UIViewController *rootVC = window.rootViewController;</span><br><span class="line">    if (rootVC.presentedViewController) &#123;</span><br><span class="line">        UIViewController *theVC = rootVC.presentedViewController;</span><br><span class="line">        while (theVC.presentedViewController) &#123;</span><br><span class="line">            theVC = theVC.presentedViewController;</span><br><span class="line">        &#125;</span><br><span class="line">        if ([theVC shouldAutorotate]) &#123;</span><br><span class="line">            return UIInterfaceOrientationMaskAll;</span><br><span class="line">        &#125;</span><br><span class="line">        return theVC.supportedInterfaceOrientations;</span><br><span class="line">    &#125;</span><br><span class="line">    return rootVC.supportedInterfaceOrientations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;记录各种疑难杂症&quot;&gt;&lt;a href=&quot;#记录各种疑难杂症&quot; class=&quot;headerlink&quot; title=&quot;记录各种疑难杂症&quot;&gt;&lt;/a&gt;记录各种疑难杂症&lt;/h3&gt;&lt;h3 id=&quot;1-Terminating-app-due-to-uncaught-excepti</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
    <category term="crash" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>iOS打包 fastlane多个target同时打包</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110405/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110405/</id>
    <published>2022-11-04T07:31:54.000Z</published>
    <updated>2022-11-04T07:53:58.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>突然接手了一个许久未曾更新的项目，项目中几乎全国每个城市都建了一个<code>target</code>，而手动打包的话需要很大的耐心，且浪费非常多的时间。鉴于此，在网上搜索了如何使用多<code>target</code>打包，<a href="https://www.jianshu.com/p/2893994e573b">这篇文章讲解的很详细</a>，但是涉及的其它内容太多，研究这些内容也有点费力。于是自己就编写测试、边改边测，终于花费了一个多小时，成功实现了一个傻瓜式教程<code>T_T</code>.</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>编写<code>Fastfile</code>文件，关于<code>fastlane</code>的安装就不作叙述。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">HOME_PATH = ENV[&quot;HOME&quot;] #home 路径 取系统环境变量 HOME</span><br><span class="line">IPA_BASE_PATH = &quot;#&#123;HOME_PATH&#125;/Desktop/IPA/&quot; # ipa基础路径</span><br><span class="line">FIR_IM_API_TOKEN = &quot;填写fir token&quot; #fir.im api_token</span><br><span class="line"></span><br><span class="line">def archive(schemeName, verStr, method)</span><br><span class="line"></span><br><span class="line">    verArray = verStr.split(&quot;.&quot;)</span><br><span class="line">        build = verArray.pop()</span><br><span class="line">        version = verArray.join(&quot;.&quot;)</span><br><span class="line"></span><br><span class="line">    if !schemeName</span><br><span class="line">        notification(subtitle: &quot;参数错误&quot;, message: &quot;错误信息：请输入 schemeName&quot;)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if !version</span><br><span class="line">        notification(subtitle:&quot;参数错误&quot;, message: &quot;错误信息：请输入 version&quot;)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    if !build</span><br><span class="line">        notification(subtitle: &quot;参数错误&quot;, message: &quot;错误信息：请输入 build&quot;)</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    puts &quot;开始打包 #&#123;schemeName&#125; #&#123;verStr&#125;&quot;</span><br><span class="line"></span><br><span class="line">    floderName = &quot;v&quot; + version + &quot;Build&quot; + build</span><br><span class="line">    if method == &quot;ad-hoc&quot;</span><br><span class="line">        dir_name = &quot;AdHoc&quot;</span><br><span class="line">    elsif method == &quot;app-store&quot;</span><br><span class="line">        dir_name = &quot;AppStore&quot;</span><br><span class="line">    elsif method == &quot;development&quot;</span><br><span class="line">        dir_name = &quot;Develop&quot;</span><br><span class="line">    else</span><br><span class="line">        dir_name = &quot;unknown&quot;</span><br><span class="line">    end</span><br><span class="line">    time = Time.new.strftime(&quot;%Y%m%d_%H%M&quot;)</span><br><span class="line">    output_directory = &quot;#&#123;IPA_BASE_PATH&#125;/#&#123;schemeName&#125;_#&#123;time&#125;/&quot; + floderName + &quot;/&quot; + dir_name</span><br><span class="line">    #编译 ipa</span><br><span class="line">    gym(</span><br><span class="line">        # 指定scheme名字</span><br><span class="line">        scheme: &quot;#&#123;schemeName&#125;&quot;,</span><br><span class="line">        # 输出的ipa名称</span><br><span class="line">        output_name: &quot;#&#123;schemeName&#125;&quot;,</span><br><span class="line">        # 是否清空以前的编译信息 true是</span><br><span class="line">        clean: true,</span><br><span class="line">        # 指定输出文件夹，这里会保存我们最后生成的ipa文件</span><br><span class="line">        output_directory: output_directory,</span><br><span class="line">        # 指定打包所使用的的输出方式，目前支持 app-store, package, ad-hoc, enterprise, development</span><br><span class="line">        export_method: method</span><br><span class="line">        )</span><br><span class="line">    return output_directory</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def eachArchive(options, method, upload)</span><br><span class="line">    string = options[:v]</span><br><span class="line"></span><br><span class="line">    tmpArray = string.split(&quot;+&quot;)</span><br><span class="line">    puts &quot;====: #&#123;options&#125;， #&#123;tmpArray&#125;&quot;</span><br><span class="line">    for tmp in tmpArray do </span><br><span class="line">        array = tmp.split(&quot;_&quot;)</span><br><span class="line">        verStr = array.pop()</span><br><span class="line">        name = array.first()</span><br><span class="line">        output_directory = archive(name, verStr, method)</span><br><span class="line">        if !output_directory</span><br><span class="line">            next</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if upload != true</span><br><span class="line">            next</span><br><span class="line">        end</span><br><span class="line">        # 上传fir</span><br><span class="line">        fir_im_upload_path = output_directory + &quot;/#&#123;name&#125;.ipa&quot;</span><br><span class="line">        puts &quot;上传FIR 路径为：&quot; + fir_im_upload_path</span><br><span class="line">        sh(&quot;fir publish #&#123;fir_im_upload_path&#125; -T #&#123;FIR_IM_API_TOKEN&#125;&quot;)</span><br><span class="line">        result_message = &quot;内测版本 #&#123;name&#125;.ipa 版本号&quot; + verStr + &quot;上传 fir.im 成功&quot;</span><br><span class="line">        notification(subtitle:&quot;🎉🎉 #&#123;method&#125; 操作成功&quot;, message:&quot;#&#123;result_message&#125;&quot;)</span><br><span class="line">        sh(&quot;say #&#123;result_message&#125;&quot;)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">  desc &quot;Description of what the lane does&quot;</span><br><span class="line">  lane :adhoc do |options|</span><br><span class="line">      eachArchive(options, &quot;ad-hoc&quot;, true)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  lane :reipa do |options|</span><br><span class="line">      eachArchive(options, &quot;app-store&quot;, false)</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>因为是傻瓜式教程，必然还是有些手动工程操作的，那就是在打不同类型的包时，需要手动在工程中改变描述文件的选择，比如打<code>Adhoc</code>包，就需要在工程中选择<code>Adhoc</code>的描述文件，其它亦如是。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>用法<br>单个<code>target</code>使用 <code>fastlane adhoc v:TestOne_1.2.3.45</code><br>多个<code>target</code>使用 <code>fastlane adhoc v:TestOne_1.2.3.45+TestTwo_1.2.34</code><br>总之就是根据自己需要打哪些<code>target</code>，就在后面拼上对应的格式，这还真是一看就会的傻瓜式方式。<br><code>+_.</code>这些符号都是为了方便区分的，当然，这个格式是可以自己手动改的，也可以直接在<code>Fastfile</code>文件中定义一个数组，而不用在命令行每次都手动拼。</p><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p><code>xcodebuild: error: The workspace named &quot;CITY&quot; does not contain a scheme named &quot;CITY&quot;. The &quot;-list&quot; option can be used to find the names of the schemes in the workspace.</code><br>解决方案是把工程中<code>scheme</code>对应的<code>project</code>改为对应的<code>Workspace</code>，如果不是<code>Workspace</code>工程的不必理会这一步。<br><img src="/images/20221104/1094796-61e4424d6680b0dd.png" alt="QQ20211209-101443.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>目前没有发现其它错误信息，虽然是傻瓜式的方式，不过也节约了不少时间，而且配置简单，一看就懂。缺点就是如果拼接格式中间有错误，就会从错误的<code>target</code>停止，但是前面已经打包好的是不受影响，可以从错误的位置再次拼接后执行。</p><p>如果你有方便的方法可以去除手动更新描述文件这一步，敬请留言🤗</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;突然接手了一个许久未曾更新的项目，项目中几乎全国每个城市都建了一个&lt;code&gt;target&lt;/code&gt;，而手动打包的话需要很大的耐心，且浪</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    <category term="打包" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/%E6%89%93%E5%8C%85/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
    <category term="fastlane" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/fastlane/"/>
    
    <category term="打包" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer、CADisplayLink、dispatch_source_t小记</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110404/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110404/</id>
    <published>2022-11-04T07:30:22.000Z</published>
    <updated>2022-11-04T07:30:55.249Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间发现了前人留下的BUG，页面间倒计时在程序进入后台后不刷新，于是又研究了一下倒计时相关的知识，在此做个汇总记录。<br>关于在后台运行的实现，有说用播放音乐的方式来做，感觉太麻烦，而且审核的时候也是一个隐患。</p><p>UI相关的代码就不放出来了，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">@interface TimerVC ()</span><br><span class="line">&#123;</span><br><span class="line">    NSTimeInterval  timerTime;</span><br><span class="line">    NSTimeInterval  displayTime;</span><br><span class="line">    NSTimeInterval  gcdTime;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSTimer   *timer;</span><br><span class="line">@property (nonatomic, strong) CADisplayLink *displayLink;</span><br><span class="line">@property (nonatomic, strong) dispatch_source_t   gcdTimer;</span><br><span class="line">@property (nonatomic, strong) NSDate    *tmpDate; ///&lt; 记录进入后台的时间</span><br><span class="line">@end</span><br><span class="line">@implementation TimerVC</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillEnterForegroundNotification object:nil];</span><br><span class="line">    [self stopGcdTimerAction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    timerTime = displayTime = gcdTime = 1000000;</span><br><span class="line">    </span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(apperBackground) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(apperForeground) name:UIApplicationWillEnterForegroundNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark reload</span><br><span class="line">// 这个方法在第一篇文章‘监听侧滑返回事件’中有介绍</span><br><span class="line">- (void)didMoveToParentViewController:(UIViewController *)parent &#123;</span><br><span class="line">    [super didMoveToParentViewController:parent];</span><br><span class="line">    if (!parent) &#123;</span><br><span class="line">     /*</span><br><span class="line">       NSTimer、CADisplayLink都会强引用self，不会自动释放，所以并不会自动走dealloc方法。</span><br><span class="line">     */</span><br><span class="line">        [self stopTimerAction];</span><br><span class="line">        [self stopDisplayLink];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -</span><br><span class="line">- (void)timerAction &#123;</span><br><span class="line">    if (self.timer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    __weak typeof(&amp;*self) weakSelf = self;</span><br><span class="line">    if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">        self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">            [weakSelf handleTimerAction];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Fallback on earlier versions</span><br><span class="line">        self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleTimerAction) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.timer fire];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    /*</span><br><span class="line">     存在延迟：不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时触发.</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleTimerAction &#123;</span><br><span class="line">    NSLog(@&quot;timer: %f&quot;, timerTime);</span><br><span class="line">    timerTime --;</span><br><span class="line">    if (timerTime &lt;= 0) &#123;</span><br><span class="line">        [self stopTimerAction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopTimerAction &#123;</span><br><span class="line">    if (self.timer) &#123;</span><br><span class="line">        [_timer invalidate];</span><br><span class="line">        _timer = nil;</span><br><span class="line">        NSLog(@&quot;timer release&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cadisplayLink &#123;</span><br><span class="line">    if (_displayLink) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink)];</span><br><span class="line">    // 间隔多少帧调用一次，默认是1，Apple屏幕刷新率默认每秒60次，即每秒调用60次。</span><br><span class="line">    self.displayLink.frameInterval = 60;</span><br><span class="line">    [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">    /*</span><br><span class="line">     CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。</span><br><span class="line">     </span><br><span class="line">     iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。不需要在格外关心屏幕的刷新频率了，本身就是跟屏幕刷新同步的。</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleDisplayLink &#123;</span><br><span class="line">    NSLog(@&quot;display: %f&quot;, displayTime);</span><br><span class="line">    displayTime --;</span><br><span class="line">    if (displayTime &lt;= 0) &#123;</span><br><span class="line">        [self displayLink];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink &#123;</span><br><span class="line">    if (_displayLink) &#123;</span><br><span class="line">        [_displayLink invalidate];</span><br><span class="line">        _displayLink = nil;</span><br><span class="line">        NSLog(@&quot;display release&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)apperBackground &#123;</span><br><span class="line">    _tmpDate = [NSDate date];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)apperForeground &#123;</span><br><span class="line">    NSDate *date = [NSDate date];</span><br><span class="line">    int second = (int)ceil([date timeIntervalSinceDate:_tmpDate]);</span><br><span class="line">    int tmp = gcdTime - second;</span><br><span class="line">    if (tmp &gt; 0) &#123;</span><br><span class="line">        gcdTime -= second;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        gcdTime = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    val = timerTime - second;</span><br><span class="line">    if (tmp &gt; 0) &#123;</span><br><span class="line">        timerTime -= second;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        timerTime = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = displayTime - second;</span><br><span class="line">    if (tmp &gt; 0) &#123;</span><br><span class="line">        displayTime -= second;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        displayTime = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)gcdTimerAction &#123;</span><br><span class="line">    if (self.gcdTimer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    _gcdTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    /*</span><br><span class="line">     dispatch_source_set_timer 当我们使用dispatch_time 或者 DISPATCH_TIME_NOW 时，系统会使用默认时钟来进行计时。然而当系统休眠的时候，默认时钟是不走的，也就会导致计时器停止。使用 dispatch_walltime 可以让计时器按照真实时间间隔进行计时。</span><br><span class="line">     但是设置为dispatch_walltime(NULL, 0)之后，如果在设置里设置日期为之前的日期，则不会再调用次方法，而设置为DISPATCH_TIME_NOW则可以</span><br><span class="line">     */</span><br><span class="line">    dispatch_source_set_timer(_gcdTimer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    __weak typeof(&amp;*self) weakSelf = self;</span><br><span class="line">    dispatch_source_set_event_handler(_gcdTimer, ^&#123;</span><br><span class="line">        [weakSelf handleGcdTimerAction];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(_gcdTimer);</span><br><span class="line">    /*</span><br><span class="line">     dispatch_suspend(&lt;#dispatch_object_t  _Nonnull object#&gt;)</span><br><span class="line">     这个是挂起，不能再这之后释放_gcdTimer，即_gcdTimer = nil;会崩溃，释放只能在dispatch_source_cancel()之后。</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleGcdTimerAction &#123;</span><br><span class="line">    NSLog(@&quot;gcd: %f&quot;, gcdTime);</span><br><span class="line">    gcdTime --;</span><br><span class="line">    if (gcdTime &lt;= 0) &#123;</span><br><span class="line">        [self stopGcdTimerAction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopGcdTimerAction &#123;</span><br><span class="line">    if (_gcdTimer) &#123;</span><br><span class="line">        dispatch_source_cancel(_gcdTimer);</span><br><span class="line">        _gcdTimer = nil;</span><br><span class="line">        NSLog(@&quot;gcd release&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>加油！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;偶然间发现了前人留下的BUG，页面间倒计时在程序进入后台后不刷新，于是又研究了一下倒计时相关的知识，在此做个汇总记录。&lt;br&gt;关于在后台运行的实现，有说用播放音乐的方式来做，感觉太麻烦，而且审核的时候也是一个隐患。&lt;/p&gt;
&lt;p&gt;UI相关的代码就不放出来了，&lt;br&gt;&lt;fig</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Masonry--更新动画</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110403/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110403/</id>
    <published>2022-11-04T07:28:15.000Z</published>
    <updated>2022-11-04T07:30:11.833Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    /// 添加视图</span><br><span class="line">    [self.view addSubviews:self.bottomView];</span><br><span class="line">   /// 1.初始布局</span><br><span class="line">    [self.bottomView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.right.mas_equalTo(0);</span><br><span class="line">        make.bottom.mas_equalTo(kBYScreen_Height);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)show &#123;</span><br><span class="line">  /// 2.在这里先对布局约束进行更新</span><br><span class="line">  [self.bottomView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.bottom.mas_equalTo(0);</span><br><span class="line">    &#125;];</span><br><span class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">        /// 注意:</span><br><span class="line">        /// 3.这里一定是要做动画的视图的父视图，或者父视图的父视图，总之就是比它辈分高的</span><br><span class="line">        [self.bottomView.superView layoutIfNeeded];</span><br><span class="line">      /// 这里可以处理其他的事情,比如改变父视图的透明度</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单记录一下，免得下一次又忘记了!!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-flex布局</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110402/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110402/</id>
    <published>2022-11-04T07:25:25.000Z</published>
    <updated>2022-11-04T07:28:58.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="伸缩容器"><a href="#伸缩容器" class="headerlink" title="伸缩容器"></a>伸缩容器</h3><p>设有<code>display:flex</code>或者<code>display:block</code>的元素就是一个<code>flex Container(伸缩容器)</code>，里面的子元素称为<code>flex item(伸缩项目)</code>，<code>flex container</code>中子元素都是使用<code>Flex</code>布局排版。</p><p><code>display:block</code>指定为块内容器模式，总是使用新行开始显示，微信小程序的<code>视图容器(view,scroll-view和swiper)</code>默认都是<code>dispaly:block</code>。</p><p><code>display:flex</code>指定为行内容器模式，在一行内显示子元素，可以使用<code>flex-wrap</code>属性指定其是否换行，<code>flex-wrap</code>有三个值:<code>nowrap</code>(不换行),<code>wrap</code>(换行),<code>wrap-reverse</code>(换行第一行在下面)</p><h3 id="主轴-main-axis-和侧轴-cross-axis"><a href="#主轴-main-axis-和侧轴-cross-axis" class="headerlink" title="主轴(main axis)和侧轴(cross axis)"></a>主轴(main axis)和侧轴(cross axis)</h3><p>从左到右、从右到左、从上到下、从下到上，都可以指定主轴的起点和终点，与主轴垂直方向的为侧轴，也有相应的起点和终点。</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><ol><li>row 从左到右的水平方向为主轴</li><li>row-reverse 从右到左的水平方向为主轴</li><li>column 从上到下的垂直方向为主轴</li><li>column-reverse 从下到上的垂直方向为主轴</li></ol><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>子元素有两种对齐方式</p><p><code>justify-content</code> 定义子元素在主轴上面的对齐方式</p><p><code>align-items</code> 定义子元素在侧轴上对齐的方式</p><blockquote><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><ol><li>flex-start 主轴起点对齐</li><li>flex-end 主轴终点对齐</li><li>center 主轴方向居中对齐</li><li>space-between 两端对齐，两端子元素分别靠两端对齐，其他子元素之间间隔相等</li><li>space-around 每个子元素之间间距相等，两端子元素间距父容器与其他子元素间距相等</li></ol></blockquote><p><code>justify-content</code>的对齐方式与主轴方向相关。</p><blockquote><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><ol><li>stretch 填充整个容器</li><li>flex-start 侧轴的起点对齐</li><li>flex-end 侧轴的终点对齐</li><li>center 侧轴方向居中对齐</li><li>baseline 以子元素的第一行文本对齐</li></ol></blockquote><p><code>align-items</code>的对齐方式与侧轴方向有关</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.wxml 文件</span><br><span class="line"></span><br><span class="line">&lt;view class=&quot;test_container&quot;&gt;</span><br><span class="line">  &lt;view class=&quot;test_top&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;test_title&quot;&gt;测试文本&lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;test_select&quot;&gt;按钮&lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;view class=&quot;test_bottom&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;test_left&quot;&gt;</span><br><span class="line">      &lt;input placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;test_center&quot;&gt;到&lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;test_right&quot;&gt;</span><br><span class="line">      &lt;input placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">.wxss 文件</span><br><span class="line"></span><br><span class="line">.test_container &#123;</span><br><span class="line">  padding: 50rpx;</span><br><span class="line">&#125;</span><br><span class="line">.test_top &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: flex-start;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.test_title &#123;</span><br><span class="line">  width: 160rpx;</span><br><span class="line">  line-height: 50rpx;</span><br><span class="line">&#125;</span><br><span class="line">.test_select &#123;</span><br><span class="line">  width: 120rpx;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 50rpx;</span><br><span class="line">  background: blue;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">&#125;</span><br><span class="line">.test_bottom &#123;</span><br><span class="line">  margin-left: 160rpx;</span><br><span class="line">  margin-top: 30rpx;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: flex-start;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.test_left &#123;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.test_center &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.test_right &#123;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;伸缩容器&quot;&gt;&lt;a href=&quot;#伸缩容器&quot; class=&quot;headerlink&quot; title=&quot;伸缩容器&quot;&gt;&lt;/a&gt;伸缩容器&lt;/h3&gt;&lt;p&gt;设有&lt;code&gt;display:flex&lt;/code&gt;或者&lt;code&gt;display:block&lt;/code&gt;的元素就是一个</summary>
      
    
    
    
    <category term="小程序" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="小程序" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="Weex" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>iOS监听系统侧滑返回事件</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110401/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/2022110401/</id>
    <published>2022-11-04T07:16:08.000Z</published>
    <updated>2022-11-04T07:24:17.416Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIViewController</code>方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToParentViewController:(UIViewController)parent</span><br><span class="line">- (void)didMoveToParentViewController:(UIViewController)parent</span><br></pre></td></tr></table></figure><br>这两个方法是系统写的类别<code>UIContainerViewControllerCallbacks</code>中的方法。<br>只需要在当前使用的控制器中重写这两个方法就可以了，第一次push进来的时候两个方法都会调用，parent的值不为空。当开始使用系统侧滑的时候，会先调用willMove，而parent的值为空；当滑动结束后返回了上个页面，则会调用didMove，parent的值也为空，如果滑动结束没有返回上个页面，也就是轻轻划了一下还在当前页面，那么则不会调用didMove方法。<br>所以如果想要在侧滑返回后在上个页面做一些操作的话，可以在didMove方法中根据parent的值来判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToParentViewController:(UIViewController)parent&#123;</span><br><span class="line">        [superwillMoveToParentViewController:parent];</span><br><span class="line">        NSLog(@&quot;%s,%@&quot;,FUNCTION,parent);</span><br><span class="line">&#125;</span><br><span class="line">- (void)didMoveToParentViewController:(UIViewController)parent&#123;</span><br><span class="line">        [superdidMoveToParentViewController:parent];</span><br><span class="line">        NSLog(@&quot;%s,%@&quot;,FUNCTION,parent);</span><br><span class="line">        if(!parent)&#123;</span><br><span class="line">            NSLog(@&quot;页面pop成功了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/b7331546a18b">原文地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;UIViewController&lt;/code&gt;方法&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/iOS/"/>
    
    <category term="侧滑返回" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/%E4%BE%A7%E6%BB%91%E8%BF%94%E5%9B%9E/"/>
    
  </entry>
  
  <entry>
    <title>地址迁移</title>
    <link href="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/hello-world/"/>
    <id>https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/2022/11/04/hello-world/</id>
    <published>2022-11-04T03:55:52.189Z</published>
    <updated>2022-11-04T07:35:30.395Z</updated>
    
    <content type="html"><![CDATA[<p>近来简书网站总是报错打不开，于是尝试搭建一个简洁的记录文档，内容迁移到这里。<br><a href="https://www.jianshu.com/u/40ce3abe6698">简书</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近来简书网站总是报错打不开，于是尝试搭建一个简洁的记录文档，内容迁移到这里。&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/u/40ce3abe6698&quot;&gt;简书&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Blog" scheme="https://github.com/GUIYIVIEW/GUIYIVIEW.github.io.git/tags/Blog/"/>
    
  </entry>
  
</feed>
