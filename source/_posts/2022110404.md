---
title: NSTimer、CADisplayLink、dispatch_source_t小记
date: 2022-11-04 15:30:22
tags:
- iOS
categories:
- iOS
---

偶然间发现了前人留下的BUG，页面间倒计时在程序进入后台后不刷新，于是又研究了一下倒计时相关的知识，在此做个汇总记录。
关于在后台运行的实现，有说用播放音乐的方式来做，感觉太麻烦，而且审核的时候也是一个隐患。

UI相关的代码就不放出来了，
```
@interface TimerVC ()
{
    NSTimeInterval  timerTime;
    NSTimeInterval  displayTime;
    NSTimeInterval  gcdTime;
}
@property (nonatomic, strong) NSTimer   *timer;
@property (nonatomic, strong) CADisplayLink *displayLink;
@property (nonatomic, strong) dispatch_source_t   gcdTimer;
@property (nonatomic, strong) NSDate    *tmpDate; ///< 记录进入后台的时间
@end
@implementation TimerVC
- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidEnterBackgroundNotification object:nil];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationWillEnterForegroundNotification object:nil];
    [self stopGcdTimerAction];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    timerTime = displayTime = gcdTime = 1000000;
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(apperBackground) name:UIApplicationDidEnterBackgroundNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(apperForeground) name:UIApplicationWillEnterForegroundNotification object:nil];
}
#pragma mark reload
// 这个方法在第一篇文章‘监听侧滑返回事件’中有介绍
- (void)didMoveToParentViewController:(UIViewController *)parent {
    [super didMoveToParentViewController:parent];
    if (!parent) {
     /*
       NSTimer、CADisplayLink都会强引用self，不会自动释放，所以并不会自动走dealloc方法。
     */
        [self stopTimerAction];
        [self stopDisplayLink];
    }
}
#pragma mark -
- (void)timerAction {
    if (self.timer) {
        return;
    }
    __weak typeof(&*self) weakSelf = self;
    if (@available(iOS 10.0, *)) {
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakSelf handleTimerAction];
        }];
    } else {
        // Fallback on earlier versions
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleTimerAction) userInfo:nil repeats:YES];
    }
    [self.timer fire];
    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
    /*
     存在延迟：不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时触发.
     */
}

- (void)handleTimerAction {
    NSLog(@"timer: %f", timerTime);
    timerTime --;
    if (timerTime <= 0) {
        [self stopTimerAction];
    }
}

- (void)stopTimerAction {
    if (self.timer) {
        [_timer invalidate];
        _timer = nil;
        NSLog(@"timer release");
    }
}

- (void)cadisplayLink {
    if (_displayLink) {
        return;
    }
    self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink)];
    // 间隔多少帧调用一次，默认是1，Apple屏幕刷新率默认每秒60次，即每秒调用60次。
    self.displayLink.frameInterval = 60;
    [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    /*
     CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。
     
     iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。不需要在格外关心屏幕的刷新频率了，本身就是跟屏幕刷新同步的。
     */
}

- (void)handleDisplayLink {
    NSLog(@"display: %f", displayTime);
    displayTime --;
    if (displayTime <= 0) {
        [self displayLink];
    }
}

- (void)stopDisplayLink {
    if (_displayLink) {
        [_displayLink invalidate];
        _displayLink = nil;
        NSLog(@"display release");
    }
}

- (void)apperBackground {
    _tmpDate = [NSDate date];
}

- (void)apperForeground {
    NSDate *date = [NSDate date];
    int second = (int)ceil([date timeIntervalSinceDate:_tmpDate]);
    int tmp = gcdTime - second;
    if (tmp > 0) {
        gcdTime -= second;
    }
    else {
        gcdTime = 0;
    }
    val = timerTime - second;
    if (tmp > 0) {
        timerTime -= second;
    }
    else {
        timerTime = 0;
    }
    tmp = displayTime - second;
    if (tmp > 0) {
        displayTime -= second;
    }
    else {
        displayTime = 0;
    }
}

- (void)gcdTimerAction {
    if (self.gcdTimer) {
        return;
    }
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    _gcdTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    /*
     dispatch_source_set_timer 当我们使用dispatch_time 或者 DISPATCH_TIME_NOW 时，系统会使用默认时钟来进行计时。然而当系统休眠的时候，默认时钟是不走的，也就会导致计时器停止。使用 dispatch_walltime 可以让计时器按照真实时间间隔进行计时。
     但是设置为dispatch_walltime(NULL, 0)之后，如果在设置里设置日期为之前的日期，则不会再调用次方法，而设置为DISPATCH_TIME_NOW则可以
     */
    dispatch_source_set_timer(_gcdTimer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);
    __weak typeof(&*self) weakSelf = self;
    dispatch_source_set_event_handler(_gcdTimer, ^{
        [weakSelf handleGcdTimerAction];
    });
    dispatch_resume(_gcdTimer);
    /*
     dispatch_suspend(<#dispatch_object_t  _Nonnull object#>)
     这个是挂起，不能再这之后释放_gcdTimer，即_gcdTimer = nil;会崩溃，释放只能在dispatch_source_cancel()之后。
     */
}

- (void)handleGcdTimerAction {
    NSLog(@"gcd: %f", gcdTime);
    gcdTime --;
    if (gcdTime <= 0) {
        [self stopGcdTimerAction];
    }
}

- (void)stopGcdTimerAction {
    if (_gcdTimer) {
        dispatch_source_cancel(_gcdTimer);
        _gcdTimer = nil;
        NSLog(@"gcd release");
    }
}

@end
```
加油！！！
