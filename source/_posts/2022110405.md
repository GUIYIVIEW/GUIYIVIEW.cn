---
title: iOS打包 fastlane多个target同时打包
date: 2022-11-04 15:31:54
tags:
- iOS
- fastlane
- 打包
categories:
- iOS
- 打包
---

### 前言
突然接手了一个许久未曾更新的项目，项目中几乎全国每个城市都建了一个`target`，而手动打包的话需要很大的耐心，且浪费非常多的时间。鉴于此，在网上搜索了如何使用多`target`打包，[这篇文章讲解的很详细](https://www.jianshu.com/p/2893994e573b)，但是涉及的其它内容太多，研究这些内容也有点费力。于是自己就编写测试、边改边测，终于花费了一个多小时，成功实现了一个傻瓜式教程`T_T`.

### 第一步
编写`Fastfile`文件，关于`fastlane`的安装就不作叙述。
```
default_platform(:ios)

HOME_PATH = ENV["HOME"] #home 路径 取系统环境变量 HOME
IPA_BASE_PATH = "#{HOME_PATH}/Desktop/IPA/" # ipa基础路径
FIR_IM_API_TOKEN = "填写fir token" #fir.im api_token

def archive(schemeName, verStr, method)

    verArray = verStr.split(".")
        build = verArray.pop()
        version = verArray.join(".")

    if !schemeName
        notification(subtitle: "参数错误", message: "错误信息：请输入 schemeName")
        return
    end

    if !version
        notification(subtitle:"参数错误", message: "错误信息：请输入 version")
        return
    end
    
    if !build
        notification(subtitle: "参数错误", message: "错误信息：请输入 build")
        return
    end

    puts "开始打包 #{schemeName} #{verStr}"

    floderName = "v" + version + "Build" + build
    if method == "ad-hoc"
        dir_name = "AdHoc"
    elsif method == "app-store"
        dir_name = "AppStore"
    elsif method == "development"
        dir_name = "Develop"
    else
        dir_name = "unknown"
    end
    time = Time.new.strftime("%Y%m%d_%H%M")
    output_directory = "#{IPA_BASE_PATH}/#{schemeName}_#{time}/" + floderName + "/" + dir_name
    #编译 ipa
    gym(
        # 指定scheme名字
        scheme: "#{schemeName}",
        # 输出的ipa名称
        output_name: "#{schemeName}",
        # 是否清空以前的编译信息 true是
        clean: true,
        # 指定输出文件夹，这里会保存我们最后生成的ipa文件
        output_directory: output_directory,
        # 指定打包所使用的的输出方式，目前支持 app-store, package, ad-hoc, enterprise, development
        export_method: method
        )
    return output_directory
end

def eachArchive(options, method, upload)
    string = options[:v]

    tmpArray = string.split("+")
    puts "====: #{options}， #{tmpArray}"
    for tmp in tmpArray do 
        array = tmp.split("_")
        verStr = array.pop()
        name = array.first()
        output_directory = archive(name, verStr, method)
        if !output_directory
            next
        end

        if upload != true
            next
        end
        # 上传fir
        fir_im_upload_path = output_directory + "/#{name}.ipa"
        puts "上传FIR 路径为：" + fir_im_upload_path
        sh("fir publish #{fir_im_upload_path} -T #{FIR_IM_API_TOKEN}")
        result_message = "内测版本 #{name}.ipa 版本号" + verStr + "上传 fir.im 成功"
        notification(subtitle:"🎉🎉 #{method} 操作成功", message:"#{result_message}")
        sh("say #{result_message}")
    end
end

platform :ios do
  desc "Description of what the lane does"
  lane :adhoc do |options|
      eachArchive(options, "ad-hoc", true)
  end

  lane :reipa do |options|
      eachArchive(options, "app-store", false)
  end
end

```
### 第二步
因为是傻瓜式教程，必然还是有些手动工程操作的，那就是在打不同类型的包时，需要手动在工程中改变描述文件的选择，比如打`Adhoc`包，就需要在工程中选择`Adhoc`的描述文件，其它亦如是。

### 第三步
用法
单个`target`使用 `fastlane adhoc v:TestOne_1.2.3.45`
多个`target`使用 `fastlane adhoc v:TestOne_1.2.3.45+TestTwo_1.2.34`
总之就是根据自己需要打哪些`target`，就在后面拼上对应的格式，这还真是一看就会的傻瓜式方式。
`+_.`这些符号都是为了方便区分的，当然，这个格式是可以自己手动改的，也可以直接在`Fastfile`文件中定义一个数组，而不用在命令行每次都手动拼。

### 错误
`xcodebuild: error: The workspace named "CITY" does not contain a scheme named "CITY". The "-list" option can be used to find the names of the schemes in the workspace.`
解决方案是把工程中`scheme`对应的`project`改为对应的`Workspace`，如果不是`Workspace`工程的不必理会这一步。
![QQ20211209-101443.png](/images/20221104/1094796-61e4424d6680b0dd.png)

### 结尾
目前没有发现其它错误信息，虽然是傻瓜式的方式，不过也节约了不少时间，而且配置简单，一看就懂。缺点就是如果拼接格式中间有错误，就会从错误的`target`停止，但是前面已经打包好的是不受影响，可以从错误的位置再次拼接后执行。

如果你有方便的方法可以去除手动更新描述文件这一步，敬请留言🤗

